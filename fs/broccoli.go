// Package fs implements virtual file system access for compressed files.
package fs

import (
	"os"
	"path/filepath"
	"sort"
	"strings"
)

// Broccoli is a virtual file system of brotli-compressed assets.
//
// This object is generated by broccoli the tool in the following
// fashion:
//
//     //go:generate broccoli src=asset1,asset2... -o filename -var br
//
type Broccoli struct {
	Files     map[string]*File
	filePaths []string
}

// Open opens the named file for reading. If successful, methods on
// the returned file can be used for reading.
func (br *Broccoli) Open(filepath string) (*File, error) {
	filepath = normalize(filepath)

	if file, ok := br.Files[filepath]; ok {
		if err := file.Open(); err != nil {
			return nil, err
		}
		return file, nil
	}

	return nil, os.ErrNotExist
}

// Stat returns a FileInfo describing the named file.
func (br *Broccoli) Stat(path string) (os.FileInfo, error) {
	path = normalize(path)

	if file, ok := br.Files[path]; ok {
		return file, nil
	}

	return nil, os.ErrNotExist
}

// Walk walks the file tree rooted at root, calling walkFn for each file or
// directory in the tree, including root. All errors that arise visiting files
// and directories are filtered by walkFn. The files are walked in lexical
// order, which makes the output deterministic but means that for very
// large directories Walk can be inefficient.
// Walk does not follow symbolic links.
func (br *Broccoli) Walk(root string, walkFn filepath.WalkFunc) error {
	root = normalize(root)

	pos := sort.SearchStrings(br.filePaths, root)
	for ; pos < len(br.filePaths) && strings.HasPrefix(br.filePaths[pos], root); pos++ {
		file := br.Files[br.filePaths[pos]]
		err := walkFn(file.Fpath, file, nil)
		if err != nil {
			return err
		}
	}

	return nil
}

func normalize(path string) string {
	if strings.HasPrefix(path, "./") {
		return path[2:]
	}

	if strings.HasPrefix(path, "/") {
		return path[1:]
	}
	if strings.HasSuffix(path, "/") {
		return path[:len(path)-1]
	}

	return path
}
